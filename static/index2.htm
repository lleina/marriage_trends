<html>
<head>
    <!---Imports d3--->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .gridlines line {
            stroke: #bbb;
        }

        .gridlines .domain {
            stroke: none;
        }
        
        .line {
            fill: none;
            stroke: steelblue;
            stroke-width: 2;
        }
        
        .dot {
            fill: steelblue; /* Fills the circles with the same color as the line */
            stroke: steelblue;
            stroke-width: 2;
        }
    </style>
</head>
<body>
    <div>
        <!-- Single Dropdown for Race OR Education -->
        <label for="categorySelect">Select Category:</label>
        <select id="categorySelect">
            <optgroup label="Race">
                <option value="all_2534">All</option>
                <option value="White_2534">White</option>
                <option value="Black_2534">Black</option>
                <!-- Add other races -->
            </optgroup>
            <optgroup label="Education">
                <option value="HS_2534">High School</option>
                <option value="BAp_2534">Bachelor's or Higher</option>
                <!-- Add other education levels -->
            </optgroup>
        </select>

        <button id="addLine">Add Line</button>
    </div>
    <svg id="linesvg" height="500" width="800" style="border:1px solid rgb(0, 0, 0)"></svg>

    <script>
        const linesvg = d3.select("svg#linesvg");
        const width = linesvg.attr("width");
        const height = linesvg.attr("height");
        const margins = { top: 10, right: 10, bottom: 50, left: 50 };
        const lineWidth = width - margins.left - margins.right;
        const lineHeight = height - margins.top - margins.bottom;

        const requestData = async function () {

            d3.csv('./both_sexes.csv', d3.autoType)
                .then((data) => {
                    const yearExtent = d3.extent(data, d => d['year']);
                    const yearScale = d3.scaleLinear().domain(yearExtent).range([0, lineWidth])

                    const marriageExtent = d3.extent(data, d => (1 - d['all_2534']));
                    const marriageScale = d3.scaleLinear().domain(marriageExtent).range([lineHeight, 0])

                    // Draw gridlines first
                    let leftGridlines = d3.axisLeft(marriageScale)
                        .tickSize(-lineWidth - 10)
                        .tickFormat('');
                    linesvg.append('g').attr('class', 'gridlines')
                        .attr('transform', `translate(${margins.left - 10},${margins.top})`)
                        .call(leftGridlines)

                    let bottomGridlines = d3.axisBottom(yearScale)
                        .tickSize(-lineHeight - 10)
                        .tickFormat('')
                        .ticks(8);
                    linesvg.append('g').attr('class', 'gridlines')
                        .attr('transform', `translate(${margins.left},${lineHeight + margins.top + 10})`)
                        .call(bottomGridlines);

                    const line = d3.line()
                        .x(d => yearScale(d['year']))
                        .y(d => marriageScale(1 - d['all_2534']))
                        .curve(d3.curveMonotoneX); // This makes the line smoother

                    linesvg.append("path")
                        .datum(data)
                        .attr("class", "line")
                        .attr("d", line)
                        .attr('transform', `translate(${margins.left},${margins.top})`);
                    
                    // Adding dots for each data point
                    linesvg.selectAll(".dot")
                        .data(data)
                        .enter().append("circle") // Uses the enter().append() method
                        .attr("class", "dot") // Assign a class for styling
                        .attr("cx", d => yearScale(d['year']) + margins.left)
                        .attr("cy", d => marriageScale(1 - d['all_2534']) + margins.top)
                        .attr("r", 5)
                        .append("title") // Adding tooltip functionality
                        .text(d => `Year: ${d['year']}\nMarriage Rate: ${((1 - d['all_2534']) * 100).toFixed(2)}%`);

                    // Axis should be drawn after gridlines
                    let leftAxis = d3.axisLeft(marriageScale)
                        .tickFormat(d3.format('.0%'))
                        .ticks(8);
                    linesvg.append('g')
                        .attr('class', 'y axis')
                        .attr('transform', `translate(${margins.left - 10},${margins.top})`)
                        .call(leftAxis);

                    let bottomAxis = d3.axisBottom(yearScale)
                        .tickFormat(d3.format('d'))
                    linesvg.append('g')
                        .attr('class', 'y axis')
                        .attr('transform', `translate(${margins.left},${lineHeight + margins.top + 10})`)
                        .call(bottomAxis);
                })
        }

        function addFilteredLine(data, category) {
            // Filter data based on category (the function remains largely the same)

            const lineClass = `line-${category.replace('_', '-')}`;

            const line = d3.line()
                .x(d => yearScale(d.year))
                .y(d => marriageScale(1 - d[category]))
                .curve(d3.curveMonotoneX);

            linesvg.append("path")
                .datum(data)
                .attr("class", "line " + lineClass)
                .style("stroke", getRandomColor()) // Assign a color
                .attr("d", line)
                .attr('transform', `translate(${margins.left},${margins.top})`);

            // Add legend entry for this line
            addLegendEntry(category, lineClass);
        }

        document.getElementById('addLine').addEventListener('click', function() {
            const categorySelect = document.getElementById('categorySelect').value;
            addFilteredLine(data, categorySelect); // Use the global data variable
        });

        // Function to generate a random color - you might want to replace this with a predefined set of colors
        function getRandomColor() {
            var letters = '0123456789ABCDEF';
            var color = '#';
            for (var i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        function addLegendEntry(category, lineClass) {
            // Example function to add a legend entry
            // Adjust as necessary to fit the layout and style of your chart
            const legend = linesvg.append("g")
                .attr("class", "legend")
                .attr("transform", `translate(${width - 100},${20 * legendEntries.length})`); // Adjust positioning

            legend.append("circle")
                .attr("cx", 0)
                .attr("cy", 0)
                .attr("r", 5)
                .style("fill", colorForClass(lineClass));

            legend.append("text")
                .attr("x", 10)
                .attr("y", 5)
                .text(category.replace('_', ' '));
            
            legendEntries.push(category); // Keep track of legend entries
        }

        function colorForClass(lineClass) {
            // Return the color associated with a class/line
            // This could be a switch statement or a dictionary lookup
            return /* color based on lineClass */;
        }

        // Initialize an empty array to keep track of legend entries
        let legendEntries = [];


        requestData();
    </script>
</body>
</html>